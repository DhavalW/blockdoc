(function () {

	St8.Libraries('core')
		.add('storage.blockChain', function (options) {
			options = options || {};

			return function (Module) {
				var logger = {};
				logger.log = debug("logs:St8Flo:modules:core:storage:blockchain");
				logger.error = debug("errors:St8Flo:modules:core:storage:blockchain");
				logger.warn = debug("warnings:St8Flo:modules:core:storage:blockchain");


				var forge, ed25519;
				var prompt = St8.Require('node_modules/prompt');

				// Ensure required libraries exist.
				if (!G.forge) {
					if (options.forge) {
						forge = options.forge;
					} else {
						if (St8.env.isNode) {
							forge = St8.Require('node_modules/node-forge');
						} else {
							if (St8.st8Data.debug) logger.error('Error - crypto library "forge" must be included as a global, or passed as an option to the module. Aborting module.');
							return;
						}
					}
				} else {
					forge = G.forge;
				}

				if (!ed25519)
					ed25519 = forge.pki.ed25519;

				Module.keypair = ed25519.generateKeyPair();
				Module.keypair.publicKey = Module.keypair.publicKey.toString('hex');
				Module.keypair.privateKey = Module.keypair.privateKey.toString('hex');

				const BLOCKTYPES = {
					account: 1,
					standard: 2,
					toString: function (v) {
						switch (v) {
						case BLOCKTYPES.account:
							return 'account';
						case BLOCKTYPES.standard:
							return 'document';
						}
					}
				};

				var chainCache = {
					cache: {},
					put: function (id, data, replace) {
						var _self = this;
						if (replace || !_self.cache[id])
							_self.cache[id] = data;

						return _self;
					},
					get: function (id) {
						return this.cache[id];
					},
					remove: function (id, data) {
						delete this.cache[id];
						return this;
					},
					list: function () {
						return Object.keys(this.cache);
					}
				};
				var blockCache = {
					cache: {},
					put: function (id, chainID, data, replace) {
						var _self = this;
						if (replace || !_self.cache[chainID] || !_self.cache[chainID][id]){
							if(!_self.cache[chainID])
								_self.cache[chainID] = {};
							_self.cache[chainID][id] = data;
						}

						return _self;
					},
					get: function (id, chainID) {
						return this.cache[chainID][id];
					},
					remove: function (id, chainID) {
						delete this.cache[chainID][id];
						return this;
					},
					list: function () {
						return Object.keys(this.cache);
					}
				};



				/* ------------------------ St8Block --------------------------------------

					This is the main block container exposed by the module
					and contains the block data & function related to block manipulation.

					Block structure

					St8Block {
						block:{
							meta:{
								// Genesis is only added if this is a genesis block. Otherwise it does not exist.
								genesis:{
									totalHolders		-	Total number of threads that should hold this chain.
									tags				-	tag Array that describes what search terms this chain should appear under (for eg: document name)
								},

								blockType - defines the system type of block this is
								author:{
									chainID, 		-	creator's account chainID (= genesis blockID)
									chainRev		-	chain revision blockID (= blockID of the relevant chain block containing the relevant public key / permissions)
								},
								createdOn			-	Timestamp of creation
							},
							data: <arbitrary>, 		-	additional user data (this will contain the actual data, files etc)
							prev: <blockID>,		-	Previous blockID, "empty string" for genesis blocks
							chainID :<blockID>		- 	chainID of the chain that this block is part of, "empty string" for genesis blocks
							signature	:			-	Encryption signature of the above, encrypted by author's private key
							blockID : <hex buffer>	-	SHA-1 hash of the above
						},

						statePromise: <promise>		-	Placeholder, used to queue and track queued async operations.

					}
				*/


				var St8Block = function St8Block() {
					this.statePromise = Promise.resolve();
					return this;
				};


				/* ----------- NOTE - St8Block basic methods ---------------*/

				St8Block.prototype.toJSON = function () {
					return this.export();
				};
				//
				// St8Block.prototype.toString = function () {
				// 	var r = _.cloneDeep(this.block);
				// 	if (r.meta.author.publicKey)
				// 		r.meta.author.publicKey = r.meta.author.publicKey.toString('hex');
				// 	if (r.meta.author.chainRev)
				// 		r.meta.author.chainRev = r.meta.author.chainRev.toString('hex');
				// 	if (r.meta.chainRev)
				// 		r.meta.chainRev = r.meta.chainRev.toString('hex');
				// 	if (r.signature)
				// 		r.signature = r.signature.toString('hex');
				//
				// 	if (r.meta.blockType)
				// 		r.meta.blockType = BLOCKTYPES.toString(r.meta.blockType);
				//
				// 	return JSON.stringify(r, null, 4);
				// };
				//
				// St8Block.prototype.fromJSON = function (json) {
				// 	this.block = JSON.parse(json);
				// };

				St8Block.prototype.export = function () {
					return {
						block: this.block
					};
				};
				St8Block.prototype.import = function (blockData) {
					this.block = blockData.block;
					return this;
				};

				St8Block.prototype.reset = function () {
					delete this.block;
					return this;
				};


				/* ----------- NOTE - St8Block async ops ---------------*/



				St8Block.prototype.queue = function (fn) {
					this.statePromise = this.statePromise.then((e) => fn(e))
					return this;
				};
				St8Block.prototype.onError = function (fn) {
					this.statePromise = this.statePromise.catch((e) => fn(e))
					return this;
				};
				// St8Block.prototype.then = function(fn){
				// 	this.statePromise.then((e)=>fn(e))
				// 	return this;
				// };

				St8Block.prototype.promise = function () {
					return this.statePromise;
				};

				// St8Block.prototype.catch = function (fn) {
				// 	this.statePromise = this.statePromise.catch((e) => fn(e));
				// 	return this;
				// };



				/* ----------- NOTE - St8Block content helpers ---------------*/

				St8Block.prototype.getEncryptable = function (blockData) {
					var block = blockData || this.block;
					var r = {
						meta: {
							blockType: block.meta.blockType || BLOCKTYPES.standard,
							author: {
								chainID: block.meta.author.chainID,
								chainRev: block.meta.author.chainRev,
							},
							permissions: block.meta.permissions || {},
							tags:block.meta.tags || []
						},
						data: block.data,
						prev: block.prev || '',
						chainID: block.chainID || ''
					};

					if (block.meta.blockType == BLOCKTYPES.account)
						r.meta.author.publicKey = block.meta.author.publicKey;

					if (block.meta.genesis)
						r.meta.genesis = block.meta.genesis;

					return r;
				};


				St8Block.prototype.getHashable = function (blockData) {
					var block = blockData || this.block;
					return Object.assign(this.getEncryptable(), {
						signature: block.signature
					})
				};

				St8Block.prototype.getAuthor = function (blockData) {
					var block = blockData || this.block;
					return block.meta.author;
				};

				St8Block.prototype.getBlockID = function (blockData) {
					var block = blockData || this.block;
					if(block)
						return block.blockID;
					else
						return 'noid';
				};

				St8Block.prototype.getChainID = function (blockData) {
					var block = blockData || this.block;
					return block.chainID;
				};

				St8Block.prototype.getSignature = function (blockData) {
					var block = blockData || this.block;
					return block.signature;
				};

				St8Block.prototype.getBlockType = function (blockData) {
					var block = blockData || this.block;
					return block.meta.blockType;
				};

				St8Block.prototype.getTypeString = function () {
					return BLOCKTYPES.toString(this.block.meta.blockType);
				};

				St8Block.prototype.getData = function (blockData) {
					var block = blockData || this.block;
					return block.data;
				};


				/* ----------- NOTE - St8Block CR_D methods ---------------*/

				/*
					Creates a new local block from the provided data
					and assigns it to this St8Block

					blockData must be in the "block" format given above without signature or blockID.
					if blockType is account
						meta.author must contain publicKey
					if standard,
						meta.author must contain chainID & chainRev
				*/

				St8Block.prototype.create = function (blockData, privateKey, authorChain) {
					var _self = this;



					var block = _self.getEncryptable(blockData);

					if (St8.st8Data.debug) logger.log('\nConstructing block \n');

					return Promise.resolve()

						// Ensuring authorChain is St8Chain, if provided
						.then(()=>{
							if(authorChain){
								if(typeof authorChain == 'string'){
									return (new St8Chain()).fromID(authorChain);
								}
								else if(authorChain instanceof St8Chain){
									return Promise.resolve(authorChain);
								}
							}
							else
								return Promise.resolve();
						})

						// ACCOUNT CHAIN use
						// is either undefined or an instance of St8Chain
						.then((res)=>{
							authorChain = res;

							if (authorChain) {
								if (St8.st8Data.debug) logger.log('\nAccount chain is supplied. \n');

								switch (block.meta.blockType) {
								case BLOCKTYPES.account:
									console.warn('Cannot create new account blocks using existing account details. Ignoring provided authorChain.');
									break;

								case BLOCKTYPES.standard:
									if (St8.st8Data.debug) logger.log('\nCopying account details into author section \n');

									block.meta.author = {
										chainID: authorChain.getChainID(),
										chainRev: authorChain.getChainRev(),
									}
									break;
								}
							}


							// DATA VALIDATION
							switch (block.meta.blockType) {
							case BLOCKTYPES.account:
								if (!(block.meta.author && block.meta.author.publicKey))
									return new Error('Cannot create account blocks without publicKey details of author');
								break;

							case BLOCKTYPES.standard:
								if (!(block.meta.author && block.meta.author.chainID && block.meta.author.chainRev))
									return new Error('Cannot create non-account blocks without account details of author');

								// Grant update permissions to author by default
								block.meta.permissions[authorChain.getChainID()] = 'U';
								break;
							}



							if (St8.st8Data.debug) logger.log('\nSigning \n');

							// sign the payload
							block.signature = ed25519.sign({
								message: JSON.stringify(block),
								// also accepts `binary` if you want to pass a binary string
								encoding: 'utf8',
								// node.js Buffer, Uint8Array, forge ByteBuffer, binary string
								privateKey: privateKey
							}).toString('hex');

							block.blockID = forge.md.sha1
								.create()
								.update(JSON.stringify(block))
								.digest()
								.toHex();

							if (St8.st8Data.debug) logger.log('\nSigned & assigning to internal variable \n');

							_self.block = block;

						})

						// VERIFICATION
						.then(()=>{
							if (_self.getBlockType() != BLOCKTYPES.account) {
								if (St8.st8Data.debug) logger.log('\nBlock needs to be verified, since its a non-account type\n');


								return _self.verify(authorChain)
									.then((res) => {
										if (res) {
											return _self;
										} else {
											_self.reset();
											throw new Error('verification failed');
										}
									});


							} else
								return Promise.resolve(_self);
						})
						.catch((e)=>{
							if (St8.st8Data.debug) logger.error('\nError - while creating block - ', e);
							return Promise.reject(e);
						});
				};

				/*
					verifies signature against a provided publicKey OR author's account block publicKey
				*/
				St8Block.prototype.verify = function (authorChain, publicKey, revBlock) {
					var _self = this;



					// Verify account block first
					// OR skip completely if publicKey is provided.
					var promise = Promise.resolve()
						.then(() => {

							if (St8.st8Data.debug) logger.log('\nSt8Block.verify() - verifying block. Params recieved as : \npublicKey = %s\n\n authorChain = %s \n\n', publicKey, JSON.stringify(authorChain, null, 4), authorChain instanceof St8Block);

							if (_self.block.meta.blockType == BLOCKTYPES.account) {
								console.log('using embedded author publicKey [%s], because this block is an acccount block', _self.getAuthor().publicKey.toString('hex'));
								console.log('skipping author block verification');
								return _self.getAuthor().publicKey;
							}

							if (publicKey) {
								console.log('skipping author block verification');
								return Promise.resolve();
							}

							var authorBlock = authorChain.getBlock();
							if (authorChain && authorBlock.getBlockType() == BLOCKTYPES.account) {
								if (St8.st8Data.debug) logger.log('\nAuthor account provided. Validating...\n');


								var verified = ed25519.verify({
									// also accepts a forge ByteBuffer or Uint8Array
									message: JSON.stringify(authorBlock.getEncryptable()),
									encoding: 'utf-8',
									// node.js Buffer, Uint8Array, forge ByteBuffer, or binary string
									signature: Buffer.from(authorBlock.getSignature(), 'hex'),
									// node.js Buffer, Uint8Array, forge ByteBuffer, or binary string
									publicKey: Buffer.from(authorBlock.getAuthor().publicKey, 'hex')
								});

								if (verified) {
									if (St8.st8Data.debug) logger.log('\nProvided author account is valid block. Verifying users signature against provided account publicKey. \n');

									return Promise.resolve(authorBlock.getAuthor().publicKey);
								} else {
									return Promise.reject(new Error('account block [' + authorBlock.getBlockID() + '] found but failed verification'));
								}
							} else {
								return Promise.reject(new Error('retrived blockID[' + (authorBlock ? authorBlock.getBlockID() : "undefined") + '] is invalid, OR not of "account" blockType. Cannot use to authenticate'));
							}
						})

						// verify this block with a/c block publicKey
						// assuming publicKey is not provided.
						.then((pKey) => {
							if (St8.st8Data.debug) logger.log('\nAttempting to verify signature \n');

							return ed25519.verify({
								// also accepts a forge ByteBuffer or Uint8Array
								message: JSON.stringify(_self.getEncryptable()),
								encoding: 'utf-8',
								// node.js Buffer, Uint8Array, forge ByteBuffer, or binary string
								signature: Buffer.from(_self.block.signature, 'hex'),
								// node.js Buffer, Uint8Array, forge ByteBuffer, or binary string
								publicKey: Buffer.from(publicKey || pKey, 'hex')
							});
						})

						.catch((e) => {
							console.log('Error while verifying block[%s] - ', _self.block.blockID, e);
							return Promise.reject(e);
						});

					return promise;
				};



				/* ------------------------ St8Chain --------------------------------------

					This is the main public api & blockchain container exposed by the module
					and contains chain manipulation functions.

					In this architecture, An entire chain represents a single atomic data entity.
					the blocks in a chain represent revisions of that entity over time.

					Multipart data (eg large document) is stored as a primary index blockchain
					that contains IDs of each part, each of which is a blockchain too.

					Related Data are stored similarly - Each data entity has its own blockchain.
					Each relation between given data entities has its own blockchain & the data in the relation
					describes the nature of interaction / properties etc.


					St8Chain {
						chain:{
							meta:{
								// Genesis meta is generated while creating the chain & added to both chain & genesis block.
								genesis:{
									totalHolders		-	Total number of threads that should hold this chain.
									minimumHolders		-	Min needed for a confirmation (should be greater than 50% of total)
									tags				-	tag Array that describes what search terms this chain should appear under (for eg: document name)
								}
							},
							chainID :<blockID>			- 	chainID of this chain = blockID of genesis block
							chainRev:<blockID>			-	chainRev of this chain = blockID of latest block
							revBlock:<block>			-	the actual latest block
							blockIDList:<Array>			-	array of IDs of all blocks in this chain, in order (recent most is pushed last)
						},

						statePromise: <promise>			-	Placeholder, used to queue and track queued async operations.
						loaded:<boolean>				-	indicates if the Chain has been loaded, to prevent any accidental repeat load operations.
					}
				*/


				var St8Chain = function St8Chain() {
					this.statePromise = Promise.resolve();
					this.statePromiseStart = this.statePromise;

					this.reset();

					return this;
				};


				/* ----------- NOTE - St8Chain basic methods ---------------*/

				// St8Chain.prototype.toJSON = function () {
				// 	return this.chain;
				// };
				//
				// St8Chain.prototype.toString = function () {
				// 	var r = _.cloneDeep(this.chain);
				// 	if(r.revBlock && r.revBlock instanceof St8Block)
				// 		r.revBlock = "Block - "+r.revBlock.getBlockID();
				// 	if(r.genesisBlock && r.genesisBlock instanceof St8Block)
				// 		r.genesisBlock = "Block - "+ r.genesisBlock.getBlockID();
				// 	return JSON.stringify(r, null, 4);
				// };
				//
				// St8Chain.prototype.fromJSON = function (json) {
				// 	this.chain = JSON.parse(json);
				// };

				St8Chain.prototype.export = function () {
					var _self = this;
					var r = {
						chain: _.cloneDeep(_self.chain),
						blocks:[]
					};
					r.chain.revBlock = _self.chain.revBlock.export();
					r.chain.genesisBlock = _self.chain.genesisBlock.export();

					r.chain.blockIDList.forEach((bID)=>{
						r.blocks.push(_self.getBlock(bID).export());
					});

					return r;
				};
				St8Chain.prototype.import = function (chainData) {
					var _self = this;
					var block;
					_self.chain = _.cloneDeep(chainData.chain);

					_self.chain.revBlock = (new St8Block()).import(_self.chain.revBlock);
					_self.chain.genesisBlock = (new St8Block()).import(_self.chain.genesisBlock);

					chainData.blocks.forEach((b)=>{
						block =(new St8Block()).import(b);
						blockCache.put(block.getBlockID(), _self.getChainID(), block);
					});

					_self.loaded = true;

					return _self;
				};

				St8Chain.prototype.reset = function () {
					this.chain = {
						meta: {
							genesis: {
								totalHolders: 31,
								minHolders: 16,
								tags: []
							},
							permissions: []
						},
						chainID: '',
						chainRev: '',
						revBlock: null,
						genesisBlock: null,
						blockIDList: [],

					};

					this.loaded = false;

					return this;
				};


				/* ----------- NOTE - St8Chain async ops ---------------*/



				St8Chain.prototype.queue = function (fn) {
					this.statePromise = this.statePromise.then((e) => fn(e))
					return this;
				};
				St8Chain.prototype.onError = function (fn) {
					this.statePromise = this.statePromise.catch((e) => fn(e))
					return this;
				};

				St8Chain.prototype.promise = function () {
					return this.statePromise;
				};

				St8Chain.prototype.getGenesisData = function (blockData) {
					var block = blockData || this.chain;
					if (block && block.meta.genesis) {
						return {
							totalHolders: block.meta.genesis.totalHolders,
							minHolders: block.meta.genesis.minHolders,
							tags: block.meta.genesis.tags
						};
					} else {
						return {};
					}
				};

				St8Chain.prototype.show = function () {
					var _self = this;
					var block;
					console.log('\n\n\n\n------------------ CHAIN  STATE -------------------');
					console.log('Chain ID - ', _self.chain.chainID);
					console.log('Chain Rev - ', _self.chain.chainRev);
					console.log('current permissions - ', JSON.stringify(_self.chain.revBlock.block.meta.permissions || {}));
					console.log('current contents - ', JSON.stringify(_self.chain.revBlock.block.data || {}, null, 4));
					console.log('\n\n')

					_self.chain.blockIDList.forEach((bID) => {
						block = _self.getBlock(bID);
						console.log('----------------------------------------------- ');
						console.log('blockID - ', block.block.blockID);
						console.log('permissions - ', block.block.meta.permissions);
						console.log('data - ', block.block.data);
						console.log('-----------------------------------------------');

					});

					console.log('\n\n\n\n')


					return this;
				};

				St8Chain.prototype.getChainID = function () {
					return this.chain.chainID;
				};
				St8Chain.prototype.getChainRev = function () {
					return this.chain.chainRev;
				};

				St8Chain.prototype.getTypeString = function () {
					if (this.chain.genesisBlock)
						return BLOCKTYPES.toString(this.chain.genesisBlock.block.meta.blockType);
					else
						return "not loaded";
				};
				St8Chain.prototype.getOriginalAuthor = function () {
					if (this.chain.genesisBlock)
						return this.chain.genesisBlock.block.meta.author;
					else
						return {};
				};
				St8Chain.prototype.getCurrentAuthor = function () {
					if (this.chain.revBlock)
						return this.chain.revBlock.block.meta.author;
					else
						return {};
				};

				St8Chain.prototype.getBlock = function (blockID) {
					var _self = this;

					// is blockID absent or that of current rev ?
					if (!blockID || (this.chain.revBlock && blockID == this.chain.revBlock.getBlockID()))
						return this.chain.revBlock;

					// is blockID that of genesis ?
					else if (this.chain.genesisBlock && blockID == this.chain.genesisBlock.getBlockID())
						return this.chain.genesisBlock;

					// is blockID in our blockList ?
					else if (blockID) {
						if (this.chain.blockIDList.find((x) => x == blockID))
							return blockCache.get(blockID, _self.getChainID());
					}

					// required block does not belong to us,
					// either becuase its from a different chain
					// or because we are a blank placeholder that's not loaded yet.
					return null;
				};




				/* ----------- NOTE - St8Chain ThreadParam Ops / Consensus ---------------*/

				// Initialize thread Params
				Module.initParams({
					publicKey:Module.keypair.publicKey,
					chains:{}
				});

				St8Chain.prototype.updateParams = function () {
					var _self = this;
					if (_self.chain && _self.chain.chainID) {
						var chains = Module.getParams().chains;
						// NOTE- chains should only include data that is expected to be exactly same across threads.
						// Because a hash will be used on it to determine equality.
						chains[_self.chain.chainID] ={
							totalHolders:_self.chain.genesisBlock.block.meta.genesis.totalHolders,
							minHolders:_self.chain.genesisBlock.block.meta.genesis.minHolders,
							blockIDList:_self.chain.blockIDList,
							chainRev:_self.chain.chainRev,
							tags:_self.chain.revBlock.block.meta.tags,
							blockType:_self.chain.genesisBlock.block.meta.blockType,
							author:_self.chain.genesisBlock.block.meta.author
						};
						Module.setParams({
							chains: chains
						});
					}
				};
				St8Chain.prototype.clearParams = function () {
					var _self = this;
					if (_self.chain && _self.chain.chainID) {
						var chains = Module.getParams().chains;
						delete chains[_self.chain.chainID];
						Module.setParams({
							chains: chains
						});
					}
				};

				St8Chain.prototype.getHolders = function (chainID) {
					chainID = chainID || this.chain.chainID;
					var threads = St8.Router().getAll();
					return threads.filter((x) => x.params && x.params[Module.moduleName] && x.params[Module.moduleName].chains && x.params[Module.moduleName].chains[chainID]);
				};
				St8Chain.prototype.getHolderRouter = function (chainID, rebuild) {
					if(!this.holderRouter || rebuild){
						chainID = chainID || this.chain.chainID;
						this.holderRouter = St8.Router()
							.filterBy(function(){
								return this.registry.filter((x) => x.params && x.params[Module.moduleName] && x.params[Module.moduleName].chains && x.params[Module.moduleName].chains[chainID]);
							});
						return this.holderRouter;
					}else{
						return this.holderRouter;
					}
				};



				/* ----------- NOTE - St8Chain CR_D Ops ---------------*/

				var getChain = Module.Flo('getChain')
					.start()
					.pipe('c1').do((v)=>{
						v.chainData = chainCache.get(v.chainID).export();
					})
					.pumpFT()
					.end();

				St8Chain.prototype.fromID = function (chainID, options) {
					var _self = this;
					options = options || {};
					return new Promise((res, rej) => {

						if(options.checkLocal && chainCache.get(chainID))
							res(chainCache.get(chainID));


						// look in the network
						var r = _self.getHolderRouter(chainID);
						var length = r.length();
						var returnVal = [];

						/* TODO - Use p2ppubsub routing to get the jobs done
							This mechanism is about sending a packet via 'p2ppubsub' routing method
						 	rather than reading the params off threadRegistry, which could be a point of failure.
							Scratch code follows for later reference, but is commented out / disabled currently.

							Instead, Implementing as a quick query of threadRegistry for the time being.
						*/
						// r.callback((v)=>{
						// 	returnVal.push(v.data);
						// 	if(returnVal.length >= length)
						// 		res(returnVal);
						// });
						//
						// r.when((router)=> router.length() > 2)
						// .do(()=>{
						// 	r.trigger(Module.Flo('getChainSignature'),{
						// 		chainID:chainID
						// 	})
						// 	.allThreads()
						// 	.once();
						// });

						r.reSync();
						if(r.length() > 0){
							var params = {};
							var threadIDs = [];
							r.registry.forEach((x)=>{
								threadIDs.push(x.threadID);
								params[x.threadID] = x.params[Module.moduleName].chains[chainID];
							});

							var consensus = {};
							var hash;
							threadIDs.forEach((t)=>{
								hash = forge.md.sha1
									.create()
									.update(JSON.stringify(params[t]))
									.digest()
									.toHex();
								if(!consensus[hash])
									consensus[hash] = [];

								consensus[hash].push(t);
							});

							var greatest = [];
							Object.keys(consensus).forEach((k)=>{
								if(consensus[k].length > greatest.length) greatest = consensus[k];
							});

							if(options.forceGet || greatest.length >= params[greatest[0]].minHolders){

								St8.Router(greatest)
									.callback((v)=>{
										if(v.chainData){
											_self.import(v.chainData);
											res(_self);
										}else{
											rej(new Error('Remote chain pull failed'));
										}
									})
									.trigger(getChain,{
										chainID:chainID
									})
									.rolling()
									.once();
							}else{
								rej({
									chainSig: params[greatest[0]],
									threadsWin:greatest
								});
							}
						}

						else{
							rej(new Error('less than 2 holder threads'));
						}
					});

				};


				var replicateChain = Module.Flo('replicateChain')
					.start()
					.pipe('c1').do((v)=>{
						var chain = new St8Chain();

						var promise = Promise.resolve();
						if(v.append && v.chainID){
							promise = promise.then(()=>chain.fromID(v.chainID,{checkLocal:true}))
						}
						return promise.then((c)=>{
								if(c) chain = c;
								return chain.create(v.blockData,v.credentials,v.authorChain,v.append, true);
							})
							.then(()=>{
								v.status = 'ok';
								v.threadID = St8.connector.threadID;
							})
							.catch((e)=>{
								v.status = 'error';
								v.statusMsg = e.toString();
								v.threadID = St8.connector.threadID;
							});
					})
					.pumpFT()
					.end();

				St8Chain.prototype.create = function (blockData, credentials, authorChain, append, localOnly) {
					/*
						Build the block
						Build the chainIDÂ & rev
						check for conflicts in network ?
						Send to min X threads for holding, via messegner packet
					*/



					var _self = this;

					if (append) {
						var permissions = {};

						_self.chain.blockIDList.forEach((bID) => {
							permissions = Object.assign(permissions, _self.getBlock(bID).block.meta.permissions || {});
						});

						var authorID;
						if(authorChain){
							if(typeof authorChain == 'string'){
								authorID = authorChain;
							}
							else{
								authorID = authorChain.getChainID();
							}
						}else{
							return Promise.reject(new Error('append action requires an authorChain'));
						}

						switch(_self.chain.genesisBlock.getBlockType()){
							case BLOCKTYPES.account:
								if(authorID != _self.getChainID() && !(permissions[authorID] && permissions[authorID].includes('U')))
									return Promise.reject('update action not authorised on this account')
								break;
							case BLOCKTYPES.standard:
								if(!permissions[authorID] || !permissions[authorID].includes('U'))
									return Promise.reject('update action not authorised on this document')
								break;
						}

						if (blockData.meta.blockType != _self.getBlock().getBlockType())
							return Promise.reject();


					}




					return (new Promise((res, rej) => {
							if (!credentials) {
								prompt.start();
								prompt.get(['username', 'password'], function (err, result) {
									//
									// Log the results.
									//
									console.log('Command-line input received:');
									console.log('  username: ' + result.username);
									console.log('  password: ' + result.password);

									if (err) {
										rej(err);
									} else {
										res(result);
									}
								});
							} else {
								res(credentials);
							}
						}))
						.then((input) => {
							if (St8.st8Data.debug) logger.log('\nGot user inputs as %s . \n', input);

							var keypair = ed25519.generateKeyPair({
								seed: forge.md.sha1.create().update(input.username + input.password).digest().toHex().substr(0, 32)
							});

							if (St8.st8Data.debug) logger.log('\nAuth keys generated. \n');

							blockData.meta.author.publicKey = keypair.publicKey.toString('hex');

							if (append) {
								blockData.prev = _self.chain.revBlock.getChainID();
							}

							_self.chain.revBlock = new St8Block();
							return _self.chain.revBlock.create(blockData, keypair.privateKey, authorChain)

						})
						.then(() => {

							if (St8.st8Data.debug) logger.log('\nBlock built. \n');

							_self.chain.chainRev = _self.chain.revBlock.getBlockID();
							_self.chain.blockIDList.push(_self.chain.chainRev);

							if (!append) {
								_self.chain.genesisBlock = _self.chain.revBlock;
								_self.chain.chainID = _self.chain.genesisBlock.getBlockID();
							}

							_self.loaded = true;

							// Store to cache / db
							chainCache.put(_self.chain.chainID, _self);
							blockCache.put(_self.chain.revBlock.getBlockID(), _self.getChainID(),  _self.chain.revBlock);


							if (St8.st8Data.debug) logger.log('\nBlockchain [%s] created successfully. \n', _self.getChainID());
							_self.show();
							_self.updateParams();


							if(localOnly){
								return Promise.resolve(_self);
							}
							else{
								// TODO - Replicate across network
								return new Promise((res,rej)=>{
									var replicated = [];
									var router;
									if(append)
										router = _self.getHolderRouter();
									else
										router = St8.Router().top(_self.chain.genesisBlock.block.meta.genesis.totalHolders);

									console.log('\n\n--------> Attempting to REPLICATE Chain !');

									return router
										.callback((v)=>{
											// console.log('\n\n--------> replicate CALLBACK ! v = %s \n\n',JSON.stringify(v,null, 4));

											replicated.push(v);

											if(replicated.length >= _self.chain.genesisBlock.block.meta.genesis.minHolders){

												res(replicated);
											}

										})
										.when((r)=>{
											// console.log('Router registry [append = %s] - ',append, r.registry);
											if(append)
												return r.length() >= (_self.chain.genesisBlock.block.meta.genesis.totalHolders-1);
											else
												return r.length() >= (_self.chain.genesisBlock.block.meta.genesis.totalHolders-1);
										})
										.do((r)=>{
											console.log('\n\n--------> Dispatching replicate requests NOW !');
											var req = {
												blockData: blockData,
												credentials:credentials,
												authorChain:typeof authorChain =='object'? authorChain.getChainID() : authorChain,
												append:append,
												chainID:append?_self.getChainID():''
											};
											console.log('\n Request structure = ', req);
											r.trigger(replicateChain,req)
											.allThreads()
											.once();
										});
								});
							}



						})
						.catch((e) => {
							_self.clearParams();
							console.log('Error while creating chain - ', e);
							return Promise.reject(e);
						});

				};



				St8Chain.prototype.updateData = function (data, credentials, authorChain) {
					var blockData = _.cloneDeep(this.getBlock().block);
					delete blockData.prev;
					delete blockData.blockID;
					delete blockData.signature;
					delete blockData.meta.genesis;
					blockData.data = data || blockData.data;
					return this.create(blockData, credentials, authorChain,  true);
				};
				St8Chain.prototype.updatePermissions = function (permissions,credentials, authorChain) {
					var blockData = _.cloneDeep(this.getBlock().block);
					delete blockData.prev;
					delete blockData.blockID;
					delete blockData.signature;
					delete blockData.meta.genesis;
					blockData.meta.permissions = permissions || {};
					return this.create(blockData, credentials, authorChain,  true);
				};

				St8Chain.prototype.allowAccount = function (accountChain, credentials, authorChain) {
					var perm = {};
					if(typeof accountChain == 'string')
						id = accountChain;
					else{
						id = accountChain.chain.chainID;
					}
					perm[id] = "U";
					return this.updatePermissions(perm, credentials, authorChain);
				};


				St8Chain.prototype.getData = function (rev) {
					if (rev) {
						if (this.chain.blockIDList.find((x) => rev)) {
							var blk = this.getBlock(rev);
							if (blk) return blk.block.data;
						}
					} else
						return this.chain.revBlock.block.data;
				};









				Module.Block = function(options) { return new St8Block(options)};
				Module.Chain = function(options) { return new St8Chain(options)};
				Module.Block.cache = blockCache;
				Module.Chain.cache = chainCache;
				Module.constants = {
					BLOCKTYPES: BLOCKTYPES
				};
			};

		});
})();
